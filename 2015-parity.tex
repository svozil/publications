\documentclass[%
 12pt,
 reprint,
  twocolumn,
 %superscriptaddress,
 %groupedaddress,
 %unsortedaddress,
 %runinaddress,
 %frontmatterverbose,
 % preprint,
 showpacs,
 showkeys,
 preprintnumbers,
 %nofootinbib,
 %nobibnotes,
 %bibnotes,
 amsmath,amssymb,
 aps,
 % prl,
  pra,
 % prb,
 % rmp,
 %prstab,
 %prstper,
  longbibliography,
 %floatfix,
 %lengthcheck,%
 ]{revtex4-1}

\usepackage[breaklinks=true,colorlinks=true,anchorcolor=blue,citecolor=blue,filecolor=blue,menucolor=blue,pagecolor=blue,urlcolor=blue,linkcolor=blue]{hyperref}
\usepackage{url}

%\usepackage{mathptmx}% http://ctan.org/pkg/mathptmx
\usepackage{graphicx}% Include figure files

\usepackage[usenames,dvipsnames]{xcolor}

\usepackage{musixtex}

\begin{document}

\title{Determining Parity}

%\cdmtcsauthor{Karl Svozil}
%\cdmtcsaffiliation{Vienna University of Technology}
%\cdmtcstrnumber{407}
%\cdmtcsdate{September 2011}
%\coverpage


\pacs{03.65.Aa, 03.67.Ac}
\keywords{quantum algorithms, parity}
%\preprint{CDMTCS preprint nr. 407/2011}

\begin{abstract}
We consider ways of determinig the parity by quantum means.
Parity serves as a {\em Rosetta stone} for quantum computational (in-)capacities.
\end{abstract}

\maketitle




\section{Parity of states}

\subsection{Parity of two-partite binary states}

Consider the four two-partite binary basis states
$\vert 00 \rangle$,
$\vert 01 \rangle$,
$\vert 10 \rangle$,
and
$\vert 11 \rangle$.
Suppose we are interested in the even parity of these states.
Then we could construct a {\em even parity operator}
$\textsf{\textbf{P}}$
{\em via} a spectral decomposition; that is,
\begin{equation}
\begin{split}
\textsf{\textbf{P}} = 1 \cdot \textsf{\textbf{P}}_- + 0 \cdot \textsf{\textbf{P}}_+, \text { with}\\
\textsf{\textbf{P}}_- =  \vert 01 \rangle \langle 01 \vert + \vert 10 \rangle \langle 10 \vert,\\
\textsf{\textbf{P}}_+ =  \vert 00 \rangle \langle 00 \vert + \vert 11 \rangle \langle 11 \vert
,
\end{split}
\end{equation}
which yields even parity ``$0$'' on $\vert 00 \rangle$ as well as $\vert 11 \rangle$,
and
even parity ``$1$'' on $\vert 01 \rangle$ as well as $\vert 10 \rangle$, respectively.
Note that $\textsf{\textbf{P}}_-$
as well as
$\textsf{\textbf{P}}_+$
are projection operators, since they are idempotent; that is,
$\textsf{\textbf{P}}_-^2=\textsf{\textbf{P}}_-$ and
$\textsf{\textbf{P}}_+^2=\textsf{\textbf{P}}_+$.

Thereby, the basis of the two-partite binary states has been effectively equipartitioned
into two groups of even parity ``$0$'' and ``$1$;'' that is,
\begin{equation}
\big\{
   \{\vert 00 \rangle ,  \vert 11 \rangle \},
   \{\vert 01 \rangle ,  \vert 10 \rangle \}
\big\}.
\end{equation}

The states associated with the propositions
corresponding to the projection operators
$\textsf{\textbf{P}}_-$ for even parity one
and
$\textsf{\textbf{P}}_+$ for even parity zero of the two bits
are entangled;
that is, this information is only expressed in terms of a {\em relational
property} -- in this case parity -- of the two quanta between each other~\cite{Zeilinger-97,zeil-99}.


\subsection{Parity of multi-partite binary states}

This equipartinioning stategy~\cite{DonSvo01,svozil-2002-statepart-prl} to determine parity with a single query can be generalized
to determine the parity of multi-partite binary states.
Take, for example, the even parity of three-partite binary states definable by
\begin{equation}
\begin{split}
\textsf{\textbf{P}} =  1 \cdot \textsf{\textbf{P}}_- + 0 \cdot \textsf{\textbf{P}}_+, \text { with}\\
\textsf{\textbf{P}}_- =
\vert 001 \rangle \langle 001 \vert  +
\vert 010 \rangle \langle 010 \vert  +
\vert 100 \rangle \langle 100 \vert  +
\vert 111 \rangle \langle 111 \vert,\\
\textsf{\textbf{P}}_+ =
\vert 000 \rangle \langle 000 \vert  +
\vert 011 \rangle \langle 011 \vert  +
\vert 101 \rangle \langle 101 \vert  +
\vert 110 \rangle \langle 110 \vert
.
\end{split}
\end{equation}

Again, the states associated with the propositions
corresponding to the projection operators
$\textsf{\textbf{P}}_-$ for even parity one
and
$\textsf{\textbf{P}}_+$ for even parity zero of the three bits
are entangled.
The basis of the three-partite binary states has been equipartitioned
into two groups of even parity ``$0$'' and ``$1$;'' that is,
\begin{equation}
\begin{split}
\big\{
   \{\vert 000 \rangle ,
\vert 011 \rangle ,
\vert 101 \rangle ,
\vert 110 \rangle  \}, \quad
\\
   \{\vert 001 \rangle ,
\vert 010 \rangle ,
\vert 100 \rangle ,
\vert 111 \rangle  \}
\big\}.
\end{split}
\end{equation}

\section{Parity of Boolean functions}

It is well known that Deutsch's problem -- to find out whether the output of a binary function of one bit
is constant or not; that is, that whether the two outputs have even parity zero or one --
can be solved with one quantum query~\cite{nielsen-book,mermin-07}.
Therefore it might not appear totally unreasonable to
speculate that the parity of some Boolean function -- a binary function of an arbitrary number of bits --
can be determined by a single quantum query.
Even though we know that the answer is negative~\cite{Farhi-98}
it is interesting to analize the reason why this parity problem is ``difficult''
even for quantum resources, in particular, quantum parallelism.
Because an answer to this question might provide us with insights about
the (in)capacities of quantum computations in general.

Suppose we define the functional parity $P(f_i)$ of an $n$-ary function $f_i = (g_i +1)/2$
{\it via} a function $g_i (  x_1,\ldots , x_n)\in \{-1,+1\}$ and
\begin{equation}
P(g_i) = \prod_{x_1,\ldots,x_n  \in \{0,1\}} g_i (  x_1,\ldots , x_n).
\end{equation}

Let us, for the sake of a direct approach of functional parity,
consider all the $2^{2^n}$ Boolean functions $f_i(  x_1,\ldots , x_n )$,
$0\le i \le 2^{2^n}-1$ of $n$ bits, and suppose that we can represent them by the
standard quantum oracle
\begin{equation}
\begin{split}
U_i( \vert x_1,\ldots , x_n\rangle \vert y \rangle ) =\\
\vert x_1,\ldots , x_n\rangle \vert y\oplus f_i(   x_1,\ldots , x_n)\rangle
\end{split}
\end{equation}
as a means to cope with possible irreversibilities of the functions $f_i$.
Because $f_i\oplus f_i = 0$, we obtain $U_i^2 = \mathbb{I}$ and thus reversibility of the quantum oracle.
Note that all the resulting $n+1$-dimensional vectors are not necessarily mutually orthogonal.

For each particular $0\le i \le 2^{2^n}-1$, we can consider the set
\begin{equation}
F_i = \{ f_i (0,\ldots , 0),  \ldots , f_i (1,\ldots , 1) \}
\end{equation}
of all the values of $f_i$ as a function of all the $2^n$ arguments.
The set
\begin{equation}
\begin{split}
V = \{F_i \mid 0\le i \le 2^{2^n}-1 \} \\
= \big\{ \{ f_i (0,\ldots , 0),  \ldots , f_i (1,\ldots , 1) \}\mid 0\le i \le 2^{2^n}-1 \big\}
\end{split}
\end{equation}
is formed by
all the $2^{2^n+n}$ Boolean functional values $f_i(  x_1,\ldots , x_n )$.
Moreover, for every one of the $2^{2^n}$ different Boolean functions of $n$ bits the $2^n$ functional output values
characterize the behavior of this function completely.



In the next step, suppose we equipartition the set of all these functions into two groups:
those with even parity ``$0$'' and ``$1$,'' respectively.
The question now is this: can we somehow construct or find two mutually orthogonal subspaces (orthogonal projection operators)
such that all the parity ``$0$'' functions are represented in one subspace, and all the parity ``$1$'' are in the other, orthogonal one?
Because if this would be the case, then the corresponding (equi-)partition of basis vectors spanning those two subspaces
could be coded into a quantum query~\cite{DonSvo01} yielding the parity of $f_i$ in a single step.

We conjecture that involvement of one or more additional auxiliary bits
(e.g., to restore reveribility for nonreversible $f_i$'s)  cannot the improve the situation,
as any uniform (over all the functions $f_i$) and
non-adaptive procedure
will not be able to generate proper orthogonality relations.


We know that for $n=1$ this task is feasible, since (we recoded the functional value ``$0$'' to ``$-1$'')
\begin{equation}
\begin{array}{c|ccc}
f_i&P(f_i)&f_i(0)&f_i(1) \\
\hline
f_0& 0 & -1 & -1 \\
f_1& 0 & +1 & +1 \\
f_2& 1 & -1 & +1 \\
f_3& 1 & +1 & -1 \\
\end{array}
\end{equation}
and the two parity cases ``$0$'' and ``$1$,'' are coded into rthogonal subspaces spanned by $(1,1)$ and $(-1,1)$, respectively.

This is no longer true for $n=2$; due to an overabundance of functions,
the vectors corresponding to both parity cases ``$0$'' and ``$1$'' span the entire Hilbert space:
\begin{equation}
\begin{array}{c|ccccc}
f_i&P(f_i)&f_i(00)&f_i(01)&f_i(10)&f_i(11)\\
\hline
f_0& 0 & -1 & -1 & -1 & -1 \\
f_1& 0 & -1 & -1 & +1 & +1 \\
f_2& 0 & -1 & +1 & -1 & +1 \\
f_3& 0 & -1 & +1 & +1 & -1 \\
f_4& 0 & +1 & -1 & -1 & +1 \\
f_5& 0 & +1 & -1 & +1 & -1 \\
f_6& 0 & +1 & +1 & -1 & -1 \\
f_7& 0 & +1 & +1 & +1 & +1 \\
f_8& 1 & -1 & -1 & -1 & +1 \\
f_9& 1 & -1 & -1 & +1 & -1 \\
f_{10}& 1 & -1 & +1 & -1 & -1 \\
f_{11}& 1 & -1 & +1 & +1 & +1 \\
f_{12}& 1 & +1 & -1 & -1 & -1 \\
f_{13}& 1 & +1 & -1 & +1 & +1 \\
f_{14}& 1 & +1 & +1 & -1 & +1 \\
f_{15}& 1 & +1 & +1 & +1 & -1  \\
\end{array}
\end{equation}





The results of this section are also relevant with regard to Zeilinger's {\em foundational principle}~\cite{Zeilinger-97,zeil-99}
claiming that an $n$-partite system can ``carry''( that is, be specified by) exactly $n$ bits (dits in general).
The issue is what exactly is a ``specification?'' Take for example, the proposition:
{\em ``the state corresponding to all even parity 0 Boolean functions of $n$ bits.''}
This appears to be impossible to represent by Hilbert space entities for $n>2$.



\begin{acknowledgments}
This research has been partly supported by FP7-PEOPLE-2010-IRSES-269151-RANPHYS.
\end{acknowledgments}

\clearpage
\bibliography{svozil}
\end{document}




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

n = 1;

t1 = Table[f = BooleanFunction[in, n]; parity = 0;
  tab = Table[argument = (# != 0) & /@ {x1};
    parity1 = Mod[parity + Boole[f[argument[[1]]]], 2];
    parity = parity1;
    {Boole[f[argument[[1]]]]*2 - 1}, {x1, 0, 1}];
  Flatten[{parity, tab}], {in, 1, 2^(2^n)}]

MatrixForm[Sort[t1]]

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
n = 2;

t2 = Table[f = BooleanFunction[in, n];  parity = 0;
  tab = Table[argument = (# != 0) & /@ {x1,x2};
    (*If[y1 == 1, parity1 = Mod[parity + Boole[f[argument[[1]],argument[[2]]]], 2]; parity = parity1 ]; *)
    parity1 = Mod[parity + Boole[f[argument[[1]],argument[[2]]]], 2]; parity = parity1;
    Boole[f[argument[[1]],argument[[2]]]]*2 - 1, {x1, 0, 1}, {x2, 0, 1}];
  Flatten[{parity, tab}], {in, 1, 2^(2^n)}]

MatrixForm[Sort[t2]]


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

n = 1;


t1 = Table[f = BooleanFunction[in, n]; parity = 0;
  tab = Table[argument = (# != 0) & /@ {x1};
    parity1 = Mod[parity + Boole[f[argument[[1]]]], 2];
    parity = parity1;
    {Boole[f[argument[[1]]]]}, {x1, 0, 1}];
  Flatten[{parity, tab}], {in, 1, 2^(2^n)}]

MatrixForm[Sort[t1]]

(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
n = 2;

t2 = Table[f = BooleanFunction[in, n];  parity = 0;
  tab = Table[argument = (# != 0) & /@ {x1,x2};
    (*If[y1 == 1, parity1 = Mod[parity + Boole[f[argument[[1]],argument[[2]]]], 2]; parity = parity1 ]; *)
    parity1 = Mod[parity + Boole[f[argument[[1]],argument[[2]]]], 2]; parity = parity1;
    Boole[f[argument[[1]],argument[[2]]]], {x1, 0, 1}, {x2, 0, 1}];
  Flatten[{parity, tab}], {in, 1, 2^(2^n)}]

MatrixForm[Sort[t2]]
