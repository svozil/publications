(1) define a "complex cross product"

u \times v =  (\ol{u_2v_3-u_3v_2},\ol{u_3v_1-u_1v_3},\ol{u_1v_2-u_2v_1})

for the 3-dimensional vectors u=(u1,u2,u3) and v = (v_1,v_2,v_3);
where the overline "\ol{a}" stands for the complex conjugate of a

(2) write a Python program that inputs the system of vectors

a1= ( 1,0,0 )
a2= ( 0,1,0 )
a3= ( 0,0,1 )
u=(x,y,z)
b1= ( 0,y,z )
b2= ( x,0,z )
b3= ( x,y,0 )
c1= ( 0,\ol{z},-\ol{y} )
c2= ( \ol{z},0,-\ol{x} )
c3= ( \ol{y},-\ol{x},0 )
d1= ( -y\ol{y}-z\ol{z},\ol{x}y,\ol{x}z )
d2= ( x\ol{y},-x\ol{x}-z\ol{z},\ol{y}z )
d3= ( x\ol{z},y\ol{z},-x\ol{x}-y\ol{y} )
b12= ( \ol{yz},\ol{xz},-\ol{xy} )
b112= ( xy\ol{y}+xz\ol{z},-yz\ol{z},y\ol{y}z )
b212= ( -xz\ol{z},x\ol{x}y+yz\ol{z},x\ol{x}z )
b13= ( \ol{yz},-\ol{xz},\ol{xy} )
b113= ( xy\ol{y}+xz\ol{z},yz\ol{z},-y\ol{y}z )
b313= ( -xy\ol{y},x\ol{x}y,x\ol{x}z+y\ol{y}z )
b23= ( -\ol{yz},\ol{xz},\ol{xy} )
b223= ( xz\ol{z},yz\ol{z}+x\ol{x}y,-x\ol{x}z )
b323= ( xy\ol{y},-x\ol{x}y,x\ol{x}z+y\ol{y}z )

 b12c3 =  b12 \times c3
 b13c2 =  b13 \times  c2
 b23c1 =  b23 \times c1

where the overline "\ol{a}" stands for the complex conjugate of a, and

(2.1) identify x = y = z = 1, and
(2.2) evaluate those vectors, as well as
(2.3) list mutual orthogonalities among those vectors in terms of their cliques (mutually orthogonal vectors);
(2.4) identify possible multiplicities.

* do the same (1-3) with x = 1 and y = z = omega, where omega is the cube root of unity;

* do the same (1-3)  with x = 1 and y = omega, z = omega^2, where omega is the cube root of unity.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

C:\mytex>py 2025-Harding-Navara.py
--- Python Program for Vector System Analysis ---

(2.2) Evaluated Vectors (for x=y=z=1):

a1     = (1.0, 0.0, 0.0)
a2     = (0.0, 1.0, 0.0)
a3     = (0.0, 0.0, 1.0)
u      = (1.0, 1.0, 1.0)
b1     = (0.0, 1.0, 1.0)
b2     = (1.0, 0.0, 1.0)
b3     = (1.0, 1.0, 0.0)
c1     = (0.0, 1.0, -1.0)
c2     = (1.0, 0.0, -1.0)
c3     = (1.0, -1.0, 0.0)
d1     = (-2.0, 1.0, 1.0)
d2     = (1.0, -2.0, 1.0)
d3     = (1.0, 1.0, -2.0)
b12    = (1.0, 1.0, -1.0)
b112   = (2.0, -1.0, 1.0)
b212   = (-1.0, 2.0, 1.0)
b13    = (1.0, -1.0, 1.0)
b113   = (2.0, 1.0, -1.0)
b313   = (-1.0, 1.0, 2.0)
b23    = (-1.0, 1.0, 1.0)
b223   = (1.0, 2.0, -1.0)
b323   = (1.0, -1.0, 2.0)
b12c3  = (-1.0, -1.0, -2.0)
b13c2  = (1.0, 2.0, 1.0)
b23c1  = (-2.0, -1.0, -1.0)

----------------------------------------

(2.4) Vector Multiplicities (Identical Vectors):

No multiplicities found. All vectors are unique.

----------------------------------------

(2.3) Mutual Orthogonality Cliques

Orthogonality is defined by the Hermitian dot product u·v = S u?conj(v?) = 0.
We use np.vdot(v, u) for this calculation.

Found 16 mutual orthogonality cliques:

Clique 1 (Size 3):
  { a1, a2, a3 }

Clique 2 (Size 3):
  { a1, b1, c1 }

Clique 3 (Size 3):
  { a2, b2, c2 }

Clique 4 (Size 3):
  { a3, b3, c3 }

Clique 5 (Size 3):
  { b1, b112, b12 }

Clique 6 (Size 3):
  { b1, b113, b13 }

Clique 7 (Size 3):
  { b12, b12c3, c3 }

Clique 8 (Size 3):
  { b12, b2, b212 }

Clique 9 (Size 3):
  { b13, b13c2, c2 }

Clique 10 (Size 3):
  { b13, b3, b313 }

Clique 11 (Size 3):
  { b2, b223, b23 }

Clique 12 (Size 3):
  { b23, b23c1, c1 }

Clique 13 (Size 3):
  { b23, b3, b323 }

Clique 14 (Size 3):
  { c1, d1, u }

Clique 15 (Size 3):
  { c2, d2, u }

Clique 16 (Size 3):
  { c3, d3, u }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

please write a python program that exchanges consecutive (in the following list) symbols like a1, ... with consecuteive numbers like 1, ...:

{ a1, a2, a3 }
  { a1, b1, c1 }
  { a2, b2, c2 }
  { a3, b3, c3 }
  { b1, b112, b12 }
  { b1, b113, b13 }
  { b12, b12c3, c3 }
  { b12, b2, b212 }
  { b13, b13c2, c2 }
  { b13, b3, b313 }
  { b2, b223, b23 }
  { b23, b23c1, c1 }
  { b23, b3, b323 }
  { c1, d1, u }
  { c2, d2, u }
  { c3, d3, u }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


import re
from collections import OrderedDict

def parse_and_remap_cliques(input_text):
    """
    Parses a string of cliques, maps symbols to consecutive integers,
    and returns the numeric cliques and the symbol-to-number mapping.
    """
    # --- 1. Parse the input string into a list of lists ---

    # Use regex to find all symbols within curly braces for each line
    # This is robust against varying whitespace
    parsed_cliques = []
    lines = input_text.strip().split('\n')
    for line in lines:
        # Find all alphanumeric sequences (the symbols) in the line
        symbols = re.findall(r'\b[a-zA-Z0-9_]+\b', line)
        if symbols:
            parsed_cliques.append(symbols)

    # --- 2. Create the mapping from symbol to integer ---

    # Use an OrderedDict to preserve the order of first appearance,
    # though a simple dict and a counter would also work.
    # This approach builds the list of unique symbols in order.
    unique_symbols_in_order = list(OrderedDict.fromkeys(
        symbol for clique in parsed_cliques for symbol in clique
    ))

    # Create the mapping from symbol to a number starting from 1
    symbol_to_int_map = {
        symbol: i + 1 for i, symbol in enumerate(unique_symbols_in_order)
    }

    # --- 3. Substitute symbols with their new integer values ---

    numeric_cliques = []
    for clique in parsed_cliques:
        numeric_clique = [symbol_to_int_map[symbol] for symbol in clique]
        numeric_cliques.append(numeric_clique)

    return numeric_cliques, symbol_to_int_map

# The input data provided in the prompt
input_data = """
  { a1, a2, a3 }
  { a1, b1, c1 }
  { a2, b2, c2 }
  { a3, b3, c3 }
  { b1, b112, b12 }
  { b1, b113, b13 }
  { b12, b12c3, c3 }
  { b12, b2, b212 }
  { b13, b13c2, c2 }
  { b13, b3, b313 }
  { b2, b223, b23 }
  { b23, b23c1, c1 }
  { b23, b3, b323 }
  { c1, d1, u }
  { c2, d2, u }
  { c3, d3, u }
"""

# Run the process
final_cliques, mapping = parse_and_remap_cliques(input_data)

# --- 4. Print the results clearly ---

print("--- Symbol to Integer Mapping ---")
# Sort the mapping by the integer value for clear presentation
sorted_mapping = sorted(mapping.items(), key=lambda item: item[1])
for symbol, number in sorted_mapping:
    print(f"{symbol:<8} -> {number}")

print("\n--- Transformed Numeric Cliques ---")
for clique in final_cliques:
    # Format the output to look like the input
    # e.g., { 1, 2, 3 }
    clique_str = ', '.join(map(str, clique))
    print(f"  {{ {clique_str} }}")

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

C:\mytex>py 1.py
--- Symbol to Integer Mapping ---
a1       -> 1
a2       -> 2
a3       -> 3
b1       -> 4
c1       -> 5
b2       -> 6
c2       -> 7
b3       -> 8
c3       -> 9
b112     -> 10
b12      -> 11
b113     -> 12
b13      -> 13
b12c3    -> 14
b212     -> 15
b13c2    -> 16
b313     -> 17
b223     -> 18
b23      -> 19
b23c1    -> 20
b323     -> 21
d1       -> 22
u        -> 23
d2       -> 24
d3       -> 25

--- Transformed Numeric Cliques ---
  { 1, 2, 3 }
  { 1, 4, 5 }
  { 2, 6, 7 }
  { 3, 8, 9 }
  { 4, 10, 11 }
  { 4, 12, 13 }
  { 11, 14, 9 }
  { 11, 6, 15 }
  { 13, 16, 7 }
  { 13, 8, 17 }
  { 6, 18, 19 }
  { 19, 20, 5 }
  { 19, 8, 21 }
  { 5, 22, 23 }
  { 7, 24, 23 }
  { 9, 25, 23 }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



Harding Schmeis diagram with center
25 atoms
16 blocks
 0 proper subsets of blocks
 3   1  2  3
 3   1  4  5
 3   2  6  7
 3   3  8  9
 3   4 10 11
 3   4 12 13
 3  11 14  9
 3  11  6 15
 3  13 16  7
 3  13  8 17
 3   6 18 19
 3  19 20  5
 3  19  8 21
 3   5 22 23
 3   7 24 23
 3   9 25 23
24 2-valued evaluations of atoms:
1 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 1
1 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0
1 0 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 0 0 1 1 1 0 1 0
1 0 0 0 0 1 0 0 1 1 0 0 1 0 0 0 0 0 0 1 1 1 0 1 0
1 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 1
1 0 0 0 0 0 1 1 0 0 1 1 0 0 0 0 0 1 0 1 0 1 0 0 1
1 0 0 0 0 0 1 0 1 1 0 1 0 0 1 0 1 1 0 1 1 1 0 0 0
1 0 0 0 0 0 1 0 1 1 0 1 0 0 1 0 1 0 1 0 0 1 0 0 0
0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 1 0 1 0 1 1
0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 1 0 0 1 0 0
0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 1 1 1 0 1 1 1 0 1 0
0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 0 1 0 1 0
0 1 0 0 1 0 0 1 0 1 0 1 0 1 1 1 0 1 0 0 0 0 0 1 1
0 1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 1 0 0 0 0 0 1 1
0 1 0 0 1 0 0 0 1 1 0 1 0 0 1 1 1 1 0 0 1 0 0 1 0
0 1 0 0 1 0 0 0 1 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0
0 0 1 1 0 1 0 0 0 0 0 0 0 1 0 1 1 0 0 1 1 1 0 1 1
0 0 1 1 0 1 0 0 0 0 0 0 0 1 0 1 1 0 0 1 1 0 1 0 0
0 0 1 1 0 0 1 0 0 0 0 0 0 1 1 0 1 1 0 1 1 1 0 0 1
0 0 1 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 1 0 0 1 0 0 1
0 0 1 0 1 1 0 0 0 1 0 1 0 1 0 1 1 0 0 0 1 0 0 1 1
0 0 1 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 1 0 0 1 1
0 0 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 1 0 0 1 0 0 0 1
0 0 1 0 1 0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 1 0 0 0 1

set of 2-valued evaluations of atoms:
nonempty: yes
unital: yes
separating atoms: yes
separating: yes
1s on nonorthogonal atoms (=OD if no noncomplete block): no for atoms
 11/13 11/19 11/23 13/19 13/23 19/23
order determining: no for sets of atoms (ordered elements?)
 11/12
 11/4+12
 11/18
 11/6+18
 11/5+22
 11/25
 13/10
 4+11/4+12
 13/4+10
 4+13/4+10
 19/4+10
 6+19/4+10
 23/4+10
 9+23/4+10
 13/6+18
 13/21
 13/5+22
 13/24
 19/4+12
 8+19/4+12
 23/4+12
 7+23/4+12
 23/14
 9+11/5+22
 19/15
 6+11/6+18
 23/16
 7+13/5+22
 19/17
 8+13/6+18
 19/22
 19/5+22
 23/6+18
 5+23/6+18
 23/20
 5+19/5+22

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Do the same relabelling, but this time use single position numbers and small caps: 1,2,...,9,a,b,c,...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

C:\mytex>py 1.py
--- Symbol to Custom Label Mapping ---
a1       -> 1
a2       -> 2
a3       -> 3
b1       -> 4
c1       -> 5
b2       -> 6
c2       -> 7
b3       -> 8
c3       -> 9
b112     -> a
b12      -> b
b113     -> c
b13      -> d
b12c3    -> e
b212     -> f
b13c2    -> g
b313     -> h
b223     -> i
b23      -> j
b23c1    -> k
b323     -> l
d1       -> m
u        -> n
d2       -> o
d3       -> p

--- Transformed Cliques with Custom Labels ---
  { 1, 2, 3 }
  { 1, 4, 5 }
  { 2, 6, 7 }
  { 3, 8, 9 }
  { 4, a, b }
  { 4, c, d }
  { b, e, 9 }
  { b, 6, f }
  { d, g, 7 }
  { d, 8, h }
  { 6, i, j }
  { j, k, 5 }
  { j, 8, l }
  { 5, m, n }
  { 7, o, n }
  { 9, p, n }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

py hypergraph_coloring.py

123,145,267,389,4ab,4cd,be9,b6f,dg7,d8h,6ij,jk5,j8l,5mn,7on,9pn

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
