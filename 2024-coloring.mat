TwoValuedStates[{{1, 2}, {3, 4}}]

a = {{1,0,1,0},{1,0,0,1},{0,1,1,0},{0,1,0,1}}

b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]] ]}]


c = MatrixForm[Union[Table[{1, b[[i,1]] * b[[i,3]] , b[[i,1]] * b[[i,4]] , b[[i,2]] * b[[i,3]],   b[[i,2]] * b[[i,4]] }, {i, 1,  Length[a]} ] ] ]


import cdd
mat = cdd.Matrix(
[
 [1, -1, 1, 1, -1],
 [1, 1, -1, -1, 1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
linearity 3  3 4 5
begin
 5 5 rational
 1 -1 0 0 0
 1 1 0 0 0
 0 1 1 0 0
 0 1 0 1 0
 0 -1 0 0 1
end


cabello189 = {
{ 1,  2,  3,  4 },
{ 4,  5,  6,  7 },
{ 7,  8,  9, 10 },
{10, 11, 12, 13 },
{13, 14, 15, 16 },
{16, 17, 18,  1 },
{ 2,  9, 11, 18 },
{ 3,  5, 12, 14 },
{ 6,  8, 15, 17 }
}




SpeckerBug = {
{ 1,  2,  3 },
{ 3,  4,  5 },
{ 5,  6,  7 },
{ 7,  8,  9 },
{ 9, 10, 11 },
{11, 12,  1 },
{ 4, 10, 13 }
}


a= {{1,0,0,1,0,1,0,0,1,0,0,0,0},{1,0,0,0,1,0,0,1,0,1,0,0,0},{1,0,0,0,1,0,0,0,1,0,0,0,1},{0,1,0,1,0,1,0,1,0,0,1,0,0},{0,1,0,1,0,1,0,0,1,0,0,1,0},{0,1,0,1,0,0,1,0,0,0,1,0,0},{0,1,0,0,1,0,0,1,0,1,0,1,0},{0,1,0,0,1,0,0,1,0,0,1,0,1},{0,1,0,0,1,0,0,0,1,0,0,1,1},{0,0,1,0,0,1,0,1,0,1,0,1,0},{0,0,1,0,0,1,0,1,0,0,1,0,1},{0,0,1,0,0,1,0,0,1,0,0,1,1},{0,0,1,0,0,0,1,0,0,1,0,1,0},{0,0,1,0,0,0,1,0,0,0,1,0,1}};

b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]] ]}]

c = MatrixForm[Union[Table[{1, b[[i,1]] * b[[i,3]] , b[[i,3]] * b[[i,5]] , b[[i,5]] * b[[i,7]], b[[i,7]] * b[[i,9]], b[[i,9]] * b[[i,11]], b[[i,11]] * b[[i,1]] }, {i, 1,  Length[a]} ] ] ]



import cdd
mat = cdd.Matrix(
[
 [1, -1, -1, -1, -1, -1, -1],
 [1, -1, -1, -1, -1, 1, 1],
 [1, -1, -1, -1, 1, 1, -1],
 [1, -1, -1, 1, -1, -1, 1],
 [1, -1, -1, 1, 1, -1, -1],
 [1, -1, -1, 1, 1, 1, 1],
 [1, -1, 1, 1, -1, -1, -1],
 [1, 1, -1, -1, -1, -1, 1],
 [1, 1, -1, -1, 1, -1, -1],
 [1, 1, -1, -1, 1, 1, 1],
 [1, 1, 1, -1, -1, -1, -1],
 [1, 1, 1, 1, -1, -1, 1],
 [1, 1, 1, 1, 1, -1, -1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)


H-representation
linearity 1  18
begin
 18 7 rational
 1 0 0 0 1 0 0
 1 -1 0 0 1 -1 0
 1 -1 1 -1 1 -1 0
 1 0 0 -1 1 -1 0
 1 0 1 0 0 0 0
 1 1 0 0 0 0 0
 1 1 -1 1 0 0 0
 1 0 0 1 0 0 0
 1 1 -1 0 -1 0 0
 1 0 0 0 -1 0 0
 1 0 -1 1 -1 0 0
 1 1 -1 1 -1 1 0
 1 0 0 -1 0 0 0
 1 -1 1 -1 0 0 0
 1 -1 0 0 0 0 0
 1 0 0 0 0 1 0
 0 0 -1 0 0 -1 0
 0 -1 1 -1 1 -1 1
end



a= {{1,0,0,1,0,1,0,0,1,0,0,0,0},{1,0,0,0,1,0,0,1,0,1,0,0,0},{1,0,0,0,1,0,0,0,1,0,0,0,1},{0,1,0,1,0,1,0,1,0,0,1,0,0},{0,1,0,1,0,1,0,0,1,0,0,1,0},{0,1,0,1,0,0,1,0,0,0,1,0,0},{0,1,0,0,1,0,0,1,0,1,0,1,0},{0,1,0,0,1,0,0,1,0,0,1,0,1},{0,1,0,0,1,0,0,0,1,0,0,1,1},{0,0,1,0,0,1,0,1,0,1,0,1,0},{0,0,1,0,0,1,0,1,0,0,1,0,1},{0,0,1,0,0,1,0,0,1,0,0,1,1},{0,0,1,0,0,0,1,0,0,1,0,1,0},{0,0,1,0,0,0,1,0,0,0,1,0,1}};

b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]] ]}]

c = MatrixForm[Union[Table[{1, b[[i,1]] * b[[i,3]] , b[[i,3]] * b[[i,5]] , b[[i,5]] * b[[i,7]], b[[i,7]] * b[[i,9]], b[[i,9]] * b[[i,11]], b[[i,11]] * b[[i,1]], b[[i,4]] * b[[i,10]] }, {i, 1,  Length[a]} ] ] ]




import cdd
mat = cdd.Matrix(
[
 [1, -1, -1, -1, -1, -1, -1, 1],
 [1, -1, -1, -1, -1, 1, 1, -1],
 [1, -1, -1, -1, 1, 1, -1, -1],
 [1, -1, -1, 1, -1, -1, 1, 1],
 [1, -1, -1, 1, 1, -1, -1, 1],
 [1, -1, -1, 1, 1, 1, 1, -1],
 [1, -1, 1, 1, -1, -1, -1, -1],
 [1, 1, -1, -1, -1, -1, 1, 1],
 [1, 1, -1, -1, 1, -1, -1, 1],
 [1, 1, -1, -1, 1, 1, 1, -1],
 [1, 1, 1, -1, -1, -1, -1, -1],
 [1, 1, 1, 1, -1, -1, 1, -1],
 [1, 1, 1, 1, 1, -1, -1, -1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
linearity 2  18 19
begin
 19 8 rational
 1 0 0 0 1 0 0 0
 1 -1 0 0 1 -1 0 0
 1 -1 1 -1 1 -1 0 0
 1 0 0 -1 1 -1 0 0
 1 0 1 0 0 0 0 0
 1 1 0 0 0 0 0 0
 1 1 -1 1 0 0 0 0
 1 0 0 1 0 0 0 0
 1 1 -1 0 -1 0 0 0
 1 0 0 0 -1 0 0 0
 1 0 -1 1 -1 0 0 0
 1 1 -1 1 -1 1 0 0
 1 0 0 -1 0 0 0 0
 1 -1 1 -1 0 0 0 0
 1 -1 0 0 0 0 0 0
 1 0 0 0 0 1 0 0
 0 0 -1 0 0 -1 0 0
 0 -1 1 -1 1 -1 1 0
 1 0 1 0 0 1 0 1
end



KSGamma3 = {
{ 1,  2,  3  },
{ 3,  4,  5  },
{ 5,  6,  7  },
{ 7,  8,  9  },
{ 9, 10, 11  },
{11, 12,  1  },
{ 4, 10, 13  },
{14, 15, 16  },
{16, 17, 18  },
{18, 19, 20  },
{20, 21, 22  },
{22, 23, 24  },
{24, 25, 14  },
{17, 23, 26  },
{ 1, 20, 27  },
{ 7, 14, 27  }
}



triangle4D = {
{1,2,3,4},
{4,5,6,7},
{7,8,9,1},
{1,4,7,10}
}

a = {{1,0,0,0,1,0,0,0,0,0},{1,0,0,0,0,1,0,0,0,0},{0,1,0,0,1,0,0,1,0,1},{0,1,0,0,1,0,0,0,1,1},{0,1,0,0,0,1,0,1,0,1},{0,1,0,0,0,1,0,0,1,1},{0,1,0,0,0,0,1,0,0,0},{0,0,1,0,1,0,0,1,0,1},{0,0,1,0,1,0,0,0,1,1},{0,0,1,0,0,1,0,1,0,1},{0,0,1,0,0,1,0,0,1,1},{0,0,1,0,0,0,1,0,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,0,0,0,0,1,0}};

b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]] ]}]

c = MatrixForm[Union[Table[{1, b[[i,1]] * b[[i,4]] , b[[i,4]] * b[[i,7]] , b[[i,7]] * b[[i,10]], b[[i,10]] * b[[i,1]] , b[[i,10]] * b[[i,1]]}, {i, 1,  Length[a]} ] ] ]


import cdd
mat = cdd.Matrix(
[
 [1, -1, -1, 1, 1],
 [1, -1, 1, 1, -1],
 [1, 1, -1, -1, 1],
 [1, 1, 1, -1, -1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
linearity 2  5 6
begin
 6 5 rational
 1 0 1 0 0
 1 1 0 0 0
 1 0 -1 0 0
 1 -1 0 0 0
 0 1 0 1 0
 0 0 1 0 1
end






square4D =[
{1,2,3,4},
{4,5,6,7},
{7,8,9,10},
{10,11,12,1}
}

a = {{1,0,0,0,1,0,0,1,0,0,0,0},{1,0,0,0,1,0,0,0,1,0,0,0},{1,0,0,0,0,1,0,1,0,0,0,0},{1,0,0,0,0,1,0,0,1,0,0,0},{1,0,0,0,0,0,1,0,0,0,0,0},{0,1,0,0,1,0,0,1,0,0,1,0},{0,1,0,0,1,0,0,1,0,0,0,1},{0,1,0,0,1,0,0,0,1,0,1,0},{0,1,0,0,1,0,0,0,1,0,0,1},{0,1,0,0,1,0,0,0,0,1,0,0},{0,1,0,0,0,1,0,1,0,0,1,0},{0,1,0,0,0,1,0,1,0,0,0,1},{0,1,0,0,0,1,0,0,1,0,1,0},{0,1,0,0,0,1,0,0,1,0,0,1},{0,1,0,0,0,1,0,0,0,1,0,0},{0,1,0,0,0,0,1,0,0,0,1,0},{0,1,0,0,0,0,1,0,0,0,0,1},{0,0,1,0,1,0,0,1,0,0,1,0},{0,0,1,0,1,0,0,1,0,0,0,1},{0,0,1,0,1,0,0,0,1,0,1,0},{0,0,1,0,1,0,0,0,1,0,0,1},{0,0,1,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,1,0,1,0,0,1,0},{0,0,1,0,0,1,0,1,0,0,0,1},{0,0,1,0,0,1,0,0,1,0,1,0},{0,0,1,0,0,1,0,0,1,0,0,1},{0,0,1,0,0,1,0,0,0,1,0,0},{0,0,1,0,0,0,1,0,0,0,1,0},{0,0,1,0,0,0,1,0,0,0,0,1},{0,0,0,1,0,0,0,1,0,0,1,0},{0,0,0,1,0,0,0,1,0,0,0,1},{0,0,0,1,0,0,0,0,1,0,1,0},{0,0,0,1,0,0,0,0,1,0,0,1},{0,0,0,1,0,0,0,0,0,1,0,0}};

b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1 , Length[a]}, {j, 1, 12}]

c = MatrixForm[Union[Table[{1, b[[i,1]] * b[[i,4]] , b[[i,4]] * b[[i,7]] , b[[i,7]] * b[[i,10]], b[[i,1]] * b[[i,10]] }, {i, 1,  Length[a]} ] ] ]





import cdd
mat = cdd.Matrix(
[[1, -1, -1, -1, -1],
 [1, -1, -1, 1, 1],
 [1, -1, 1, 1, -1],
 [1, 1, -1, -1, 1],
 [1, 1, 1, -1, -1],
 [1, 1, 1, 1, 1]]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
linearity 1  9
begin
 9 5 rational
 1 0 0 1 0
 1 1 -1 1 0
 1 1 0 0 0
 1 0 1 0 0
 1 0 0 -1 0
 1 -1 1 -1 0
 1 0 -1 0 0
 1 -1 0 0 0
 0 -1 1 -1 1
end







firefly = {{1,2,3},{1,4,5}}

a={{1,0,0,0,0},{0,1,0,1,0},{0,1,0,0,1},{0,0,1,1,0},{0,0,1,0,1}}


b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]] ]}]

c = MatrixForm[Union[Table[{1, b[[i,2]] * b[[i,4]] , b[[i,3]] * b[[i,4]] , b[[i,2]] * b[[i,5]], b[[i,3]] * b[[i,5]] }, {i, 1,  Length[a]} ] ] ]



import cdd
mat = cdd.Matrix(
[
 [1, -1, 1, 1, -1],
 [1, 1, -1, -1, 1],
 [1, 1, 1, 1, 1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
linearity 2  4 5
begin
 5 5 rational
 1 -1 0 0 0
 1 0 -1 0 0
 0 1 1 0 0
 0 0 -1 1 0
 0 -1 0 0 1
end


a={{1,0,0,0,0},{0,1,0,1,0},{0,1,0,0,1},{0,0,1,1,0},{0,0,1,0,1}}


b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]] ]}]

c = MatrixForm[Union[Table[{1, b[[i,2]] * b[[i,4]] , b[[i,3]] * b[[i,5]] }, {i, 1,  Length[a]} ] ] ]



import cdd
mat = cdd.Matrix(
[[1, -1, -1],
 [1, 1, 1]]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
linearity 1  3
begin
 3 3 rational
 1 -1 0
 1 1 0
 0 -1 1
end


pentagon = {{1, 2, 3}, {3, 4, 5}, {5, 6, 7}, {7, 8, 9}, {9, 10, 1}}

a= {{1,0,0,1,0,1,0,1,0,0},{1,0,0,1,0,0,1,0,0,0},{1,0,0,0,1,0,0,1,0,0},{0,1,0,1,0,1,0,1,0,1},{0,1,0,1,0,1,0,0,1,0},{0,1,0,1,0,0,1,0,0,1},{0,1,0,0,1,0,0,1,0,1},{0,1,0,0,1,0,0,0,1,0},{0,0,1,0,0,1,0,1,0,1},{0,0,1,0,0,1,0,0,1,0},{0,0,1,0,0,0,1,0,0,1}};

b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]]]}]


kl = MatrixForm[Union[Table[{1, b[[i,1]] * b[[i,3]] , b[[i,3]] * b[[i,5]] , b[[i,5]] * b[[i,7]], b[[i,7]] * b[[i,9]], b[[i,9]] * b[[i,1]] }, {i, 1 , Length[b]} ] ] ]


import cdd
mat = cdd.Matrix(
[
 [1, -1, -1, -1, -1, 1],
 [1, -1, -1, -1, 1, -1],
 [1, -1, -1, 1, -1, -1],
 [1, -1, -1, 1, 1, 1],
 [1, -1, 1, -1, -1, -1],
 [1, -1, 1, 1, 1, -1],
 [1, 1, -1, -1, -1, -1],
 [1, 1, -1, -1, 1, 1],
 [1, 1, 1, -1, -1, 1],
 [1, 1, 1, 1, -1, -1],
 [1, 1, 1, 1, 1, 1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
begin
 11 6 rational
 1 0 0 0 1 0
 1 0 0 0 0 1
 1 0 1 0 0 0
 3 1 1 1 1 1
 1 1 0 0 0 0
 1 0 0 1 0 0
 1 1 -1 1 -1 -1
 1 -1 1 -1 -1 1
 1 1 -1 -1 1 -1
 1 -1 1 -1 1 -1
 1 -1 -1 1 -1 1
end

pentagon = {{1, 2, 3}, {3, 4, 5}, {5, 6, 7}, {7, 8, 9}, {9, 10, 1}}

a= {{1,0,0,1,0,1,0,1,0,0},{1,0,0,1,0,0,1,0,0,0},{1,0,0,0,1,0,0,1,0,0},{0,1,0,1,0,1,0,1,0,1},{0,1,0,1,0,1,0,0,1,0},{0,1,0,1,0,0,1,0,0,1},{0,1,0,0,1,0,0,1,0,1},{0,1,0,0,1,0,0,0,1,0},{0,0,1,0,0,1,0,1,0,1},{0,0,1,0,0,1,0,0,1,0},{0,0,1,0,0,0,1,0,0,1}};

b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]]]}]

c = MatrixForm[Union[Table[{1, b[[i,2]] * b[[i,4]] , b[[i,4]] * b[[i,6]] , b[[i,6]] * b[[i,8]], b[[i,8]] * b[[i,10]], b[[i,2]] * b[[i,10]] }, {i, 1 , Length[a]} ] ] ]


import cdd
mat = cdd.Matrix(
[
 [1, -1, -1, 1, 1, 1],
 [1, -1, 1, -1, 1, 1],
 [1, -1, 1, 1, -1, 1],
 [1, -1, 1, 1, 1, -1],
 [1, 1, -1, -1, 1, 1],
 [1, 1, -1, 1, -1, 1],
 [1, 1, -1, 1, 1, -1],
 [1, 1, 1, -1, -1, 1],
 [1, 1, 1, -1, 1, -1],
 [1, 1, 1, 1, -1, -1],
 [1, 1, 1, 1, 1, 1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
begin
 11 6 rational
 1 0 0 0 -1 0
 3 -1 -1 1 -1 -1
 3 -1 1 -1 -1 -1
 3 1 -1 -1 -1 -1
 1 0 0 0 0 -1
 3 -1 -1 -1 1 -1
 3 -1 -1 -1 -1 1
 1 0 0 -1 0 0
 1 0 -1 0 0 0
 1 -1 0 0 0 0
 -1 1 1 1 1 1
end

import cdd
mat = cdd.Matrix(
[
 [1, -1, -1, 1, 1, 1],
 [1, -1, 1, -1, 1, 1],
 [1, -1, 1, 1, -1, 1],
 [1, -1, 1, 1, 1, -1],
 [1, 1, -1, -1, 1, 1],
 [1, 1, -1, 1, -1, 1],
 [1, 1, -1, 1, 1, -1],
 [1, 1, 1, -1, -1, 1],
 [1, 1, 1, -1, 1, -1],
 [1, 1, 1, 1, -1, -1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
linearity 1  11
begin
 11 6 rational
 1 0 0 0 -1 0
 1 0 0 1 0 0
 1 0 1 0 0 0
 1 1 0 0 0 0
 0 1 1 1 1 0
 1 0 0 0 1 0
 2 -1 -1 -1 -1 0
 1 0 0 -1 0 0
 1 0 -1 0 0 0
 1 -1 0 0 0 0
 -1 1 1 1 1 1
end



c = MatrixForm[Union[Table[{1, a[[i,2]] * a[[i,4]] , a[[i,4]] * a[[i,6]] , a[[i,6]] * a[[i,8]], a[[i,8]] * a[[i,10]], a[[i,2]] * a[[i,10]] }, {i, 1,  Length[a]} ] ] ]


import cdd
mat = cdd.Matrix(
[
  [1, 0, 0, 0, 0, 0],
  [1, 0, 0, 0, 1, 1],
  [1, 0, 0, 1, 1, 0],
  [1, 0, 1, 1, 0, 0],
  [1, 1, 0, 0, 0, 1],
  [1, 1, 1, 0, 0, 0],
  [1, 1, 1, 1, 1, 1]
 ]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
begin
 10 6 rational
 0 1 1 -1 1 -1
 0 -1 1 -1 1 1
 0 1 -1 1 1 -1
 0 -1 1 1 -1 1
 0 1 -1 1 -1 1
 1 1 -2 1 -2 1
 1 -2 1 1 -2 1
 1 1 -2 1 1 -2
 1 -2 1 -2 1 1
 1 1 1 -2 1 -2
end

pentagon = {{1, 2, 3}, {3, 4, 5}, {5, 6, 7}, {7, 8, 9}, {9, 10, 1}}

a= {{1,0,0,1,0,1,0,1,0,0},{1,0,0,1,0,0,1,0,0,0},{1,0,0,0,1,0,0,1,0,0},{0,1,0,1,0,1,0,1,0,1},{0,1,0,1,0,1,0,0,1,0},{0,1,0,1,0,0,1,0,0,1},{0,1,0,0,1,0,0,1,0,1},{0,1,0,0,1,0,0,0,1,0},{0,0,1,0,0,1,0,1,0,1},{0,0,1,0,0,1,0,0,1,0},{0,0,1,0,0,0,1,0,0,1}};

b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]]]}]


d = MatrixForm[Union[Table[{1, b[[i,2]]  , b[[i,4]]  , b[[i,6]], b[[i,8]] , b[[i,10]] }, {i, 1 , Length[b]} ] ] ]

import cdd
mat = cdd.Matrix(
[
 [1, -1, -1, -1, -1, 1],
 [1, -1, -1, -1, 1, -1],
 [1, -1, -1, 1, -1, -1],
 [1, -1, -1, 1, 1, 1],
 [1, -1, 1, -1, -1, -1],
 [1, -1, 1, 1, 1, -1],
 [1, 1, -1, -1, -1, -1],
 [1, 1, -1, -1, 1, 1],
 [1, 1, 1, -1, -1, 1],
 [1, 1, 1, 1, -1, -1],
 [1, 1, 1, 1, 1, 1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
begin
 11 6 rational
 1 0 0 0 1 0
 1 0 0 0 0 1
 1 0 1 0 0 0
 3 1 1 1 1 1
 1 1 0 0 0 0
 1 0 0 1 0 0
 1 1 -1 1 -1 -1
 1 -1 1 -1 -1 1
 1 1 -1 -1 1 -1
 1 -1 1 -1 1 -1
 1 -1 -1 1 -1 1



pentagon = {{1, 2, 3}, {3, 4, 5}, {5, 6, 7}, {7, 8, 9}, {9, 10, 1}}

a= {{1,0,0,1,0,1,0,1,0,0},{1,0,0,1,0,0,1,0,0,0},{1,0,0,0,1,0,0,1,0,0},{0,1,0,1,0,1,0,1,0,1},{0,1,0,1,0,1,0,0,1,0},{0,1,0,1,0,0,1,0,0,1},{0,1,0,0,1,0,0,1,0,1},{0,1,0,0,1,0,0,0,1,0},{0,0,1,0,0,1,0,1,0,1},{0,0,1,0,0,1,0,0,1,0},{0,0,1,0,0,0,1,0,0,1}};

b = Table[ If[ a[[i, j]] == 0, -1, 1], {i, 1,  Length[a]}, {j, 1, Length[a[[1]]]}]


e = MatrixForm[Union[Table[{1, b[[i,1]]  , b[[i,3]]  , b[[i,5]], b[[i,7]] , b[[i,9]] }, {i, 1 , Length[b]} ] ] ]

import cdd
mat = cdd.Matrix(
[
 [1, -1, -1, -1, -1, -1],
 [1, -1, -1, -1, -1, 1],
 [1, -1, -1, -1, 1, -1],
 [1, -1, -1, 1, -1, -1],
 [1, -1, -1, 1, -1, 1],
 [1, -1, 1, -1, -1, -1],
 [1, -1, 1, -1, -1, 1],
 [1, -1, 1, -1, 1, -1],
 [1, 1, -1, -1, -1, -1],
 [1, 1, -1, -1, 1, -1],
 [1, 1, -1, 1, -1, -1]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
begin
 11 6 rational
 1 0 0 1 0 0
 0 0 0 0 -1 -1
 1 1 0 0 0 0
 0 0 -1 -1 0 0
 -1 -1 -1 -1 -1 -1
 0 -1 -1 0 0 0
 1 0 0 0 1 0
 0 -1 0 0 0 -1
 0 0 0 -1 -1 0
 1 0 1 0 0 0
 1 0 0 0 0 1
end

pentagon = {{1, 2, 3}, {3, 4, 5}, {5, 6, 7}, {7, 8, 9}, {9, 10, 1}}

a= {{1,0,0,1,0,1,0,1,0,0},{1,0,0,1,0,0,1,0,0,0},{1,0,0,0,1,0,0,1,0,0},{0,1,0,1,0,1,0,1,0,1},{0,1,0,1,0,1,0,0,1,0},{0,1,0,1,0,0,1,0,0,1},{0,1,0,0,1,0,0,1,0,1},{0,1,0,0,1,0,0,0,1,0},{0,0,1,0,0,1,0,1,0,1},{0,0,1,0,0,1,0,0,1,0},{0,0,1,0,0,0,1,0,0,1}};

e = MatrixForm[Union[Table[{1, a[[i,1]]  , a[[i,3]]  , a[[i,5]], a[[i,7]] , a[[i,9]] }, {i, 1 , Length[a]} ] ] ]

import cdd
mat = cdd.Matrix(
[
 [1, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 1],
 [1, 0, 0, 0, 1, 0],
 [1, 0, 0, 1, 0, 0],
 [1, 0, 0, 1, 0, 1],
 [1, 0, 1, 0, 0, 0],
 [1, 0, 1, 0, 0, 1],
 [1, 0, 1, 0, 1, 0],
 [1, 1, 0, 0, 0, 0],
 [1, 1, 0, 0, 1, 0],
 [1, 1, 0, 1, 0, 0]
]
)
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
begin
 11 6 rational
 0 0 0 1 0 0
 1 0 0 0 -1 -1
 0 1 0 0 0 0
 1 0 -1 -1 0 0
 2 -1 -1 -1 -1 -1
 1 -1 -1 0 0 0
 0 0 0 0 1 0
 1 -1 0 0 0 -1
 1 0 0 -1 -1 0
 0 0 1 0 0 0
 0 0 0 0 0 1
end

################

Quantum predictions:

f[j_] := {r  Cos[j  p], r  Sin[j  p], z}

(*

Reduce[{f[0] . f[1] == 0, f[1] . f[2] == 0, f[2] . f[3] == 0,
  f[3] . f[4] == 0, f[4] . f[0] == 0, z != 0}, {p, r, z}, Reals]

*)

p = 4 Pi /5; z = 1/2  Sqrt[1 + Sqrt[5]]; r =1;

b = ToRadicals[
   FullSimplify[
    ToRadicals[ {Normalize[f[0]], Normalize[f[1]], Normalize[f[2]], Normalize[f[3]],
 Normalize[f[4]]}
]]];

ListPointPlot3D[{b[[1]], b[[2]], b[[3]], b[[4]], b[[5]]}]

ListLinePlot3D[{b[[1]], b[[2]], b[[3]], b[[4]], b[[5]], , b[[1]]}]

c = FullSimplify[{Normalize[b[[1]]], Normalize[b[[2]]],
   Normalize[b[[3]]], Normalize[b[[4]]], Normalize[b[[1]]]}]


FullSimplify[{b[[1]] . b[[2]], b[[2]] . b[[3]],b[[3]] . b[[4]],b[[4]] . b[[5]],b[[5]] . b[[1]]}]


a= {
FullSimplify[Normalize[Cross[ b[[1]], b[[2]] ]]],
FullSimplify[Normalize[Cross[ b[[2]], b[[3]] ]]],
FullSimplify[Normalize[Cross[ b[[3]], b[[4]] ]]],
FullSimplify[Normalize[Cross[ b[[4]], b[[5]] ]]],
FullSimplify[Normalize[Cross[ b[[5]], b[[1]] ]]]
};


z ={0,0,1};
y ={0,1,0};
x ={1,0,0};


(*Definition of "my" Tensor Product*)(*a,b are nxn and mxm-matrices*)

MyTensorProduct[a_, b_] :=
  Table[a[[Ceiling[s/Length[b]], Ceiling[t/Length[b]]]]*
    b[[s - Floor[(s - 1)/Length[b]]*Length[b],
      t - Floor[(t - 1)/Length[b]]*Length[b]]], {s, 1,
    Length[a]*Length[b]}, {t, 1, Length[a]*Length[b]}];

(*Definition of the Dyadic Product*)

DyadicProductVec[x_] :=
  Table[x[[i]]  Conjugate[x[[j]]], {i, 1, Length[x]}, {j, 1,
    Length[x]}];

(*Commutator*)

Commutator[a_, b_] := a . b - b . a;



A1 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[b[[1]]]]      ;
A2 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[a[[1]]]]      ;
A3 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[b[[2]]]]      ;
A4 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[a[[2]]]]      ;
A5 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[b[[3]]]]      ;
A6 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[a[[3]]]]      ;
A7 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[b[[4]]]]      ;
A8 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[a[[4]]]]      ;
A9 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[b[[5]]]]      ;
A10 = FullSimplify[IdentityMatrix[3] - 2   DyadicProductVec[a[[5]]]]    ;



Klyachko = FullSimplify[A1.A3+A3.A5+A5.A7+A7.A9+A9.A1]

Transpose[x] . Klyachko . x
N[Transpose[x] . Klyachko . x]

Transpose[y] . Klyachko . y
N[Transpose[y] . Klyachko . y]

Transpose[z] . Klyachko . z
N[Transpose[z] . Klyachko . z]

Klyachkovec = FullSimplify[
DyadicProductVec[ b[[1]] ] +
DyadicProductVec[ b[[2]] ] +
DyadicProductVec[ b[[3]] ] +
DyadicProductVec[ b[[4]] ] +
DyadicProductVec[ b[[5]] ]
]

Transpose[x] .Klyachkovec .x

Transpose[y] .Klyachkovec .y

Transpose[z] .Klyachkovec .z

mine=   FullSimplify[A2.A4+A4.A6+A6.A8+A8.A10+A10.A2]


(*

b =
{{2/Sqrt[5 + Sqrt[5]], 0, 1/5^(1/4)}, {-(1/2) Sqrt[1 + 1/Sqrt[5]],
  Sqrt[3 - Sqrt[5]]/2, 1/5^(1/4)}, {Sqrt[
  1/2 - 1/Sqrt[5]], -(1/Sqrt[2]), 1/5^(1/4)}, {Sqrt[1/2 - 1/Sqrt[5]],
  1/Sqrt[2], 1/5^(1/4)}, {2/Sqrt[5 + Sqrt[5]], 0, 1/5^(1/4)}}

Klyachko = {{-5 + 2 Sqrt[5], 0, 0}, {0, -5 + 2 Sqrt[5], 0}, {0, 0,
  5 - 4 Sqrt[5]}}

mine = {{5 - 2 Sqrt[5], -2 Sqrt[5 (5 - 2 Sqrt[5])],
  0}, {2 Sqrt[5 (5 - 2 Sqrt[5])], 5 - 2 Sqrt[5], 0}, {0, 0,
  15 - 6 Sqrt[5]}}

*)





Klyachko = FullSimplify[A1.A3+A3.A5+A5.A7+A7.A9+A9.A1]

Transpose[{1, 0, 0}] . Klyachko . {1, 0, 0}

N[Transpose[{1, 0, 0}] . Klyachko . {1, 0, 0}]

mine=   FullSimplify[A2.A4+A4.A6+A6.A8+A8.A10+A10.A2]

mine2 = FullSimplify[A2 + A4 + A6 + A8 + A10]

(*

{{5 - 2 Sqrt[5], 0, 0},
{0, 5 - 2 Sqrt[5], 0},
{0, 0, -5 + 4 Sqrt[5]}}

{{0.527864, 0., 0.}, {0., 0.527864, 0.}, {0., 0., 3.94427}}



*)

minepsdich = ToRadicals[FullSimplify[ToRadicals[A1 + A2 + A3 + A4 + A5]]]

(*


{{1/Sqrt[
  5], -Sqrt[2 - 2/Sqrt[5]], -2 Sqrt[1/5 + 1/Sqrt[5]]},
{-Sqrt[    2 - 2/Sqrt[5]], 2 - Sqrt[5], 2 Sqrt[-1 + 3/Sqrt[5]]},
{-2 Sqrt[1/5 + 1/Sqrt[5]],   2 Sqrt[-1 + 3/Sqrt[5]], -1 + 4/Sqrt[5]}}

{{0.447214, -1.05146, -1.60899},
{-1.05146, -0.236068, 1.169},
{-1.60899, 1.169, 0.788854}}

*)

bubstairs = Klyachkovec

(*

{10/(5 + Sqrt[5]), 0, 0}, {0, 1/2 (5 - Sqrt[5]), 0}, {0, 0, Sqrt[5]}}

{{1.38197, 0., 0.}, {0., 1.38197, 0.}, {0., 0., 2.23607}}

*)



################################################################################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%################################################

Septagon:

a[j_] := {r   Cos[j   p], r   Sin[j   p], z}

Reduce[{a[0] . a[1] == 0, a[1] . a[2] == 0, a[2] . a[3] == 0,
  a[3] . a[4] == 0, a[4] . a[5] == 0, a[5] . a[6] == 0,
  a[6] . a[0] == 0, z != 0}, {p, r, z}, Reals]

ToRadicals[FullSimplify[ToRadicals[%]]]



################################################################################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%################################################

NavaraEscher = {
 {   1,  2,  3 } ,
 {   3,  4,  5 } ,
 {   5,  6,  7 } ,
 {   7,  8,  9 } ,
 {   9, 10, 11 } ,
 {  11, 12,  1 } ,
 {   4, 10, 16 } ,
 {  12, 15, 17 } ,
 {  13, 18,  6 } ,
 {   2, 13, 14 } ,
 {   8, 14, 15 } }


################################################################################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%################################################


Hextagon  = {
 {   1,  2,  3 } ,
 {   3,  4,  5 } ,
 {   5,  6,  7 } ,
 {   7,  8,  9 } ,
 {   9, 10, 11 } ,
 {  11, 12,  1 } }


b= {{-1,1,1,-1,1,-1,1,-1,1,-1,1,1},{-1,1,1,-1,1,-1,1,1,-1,1,1,1},{-1,1,1,-1,1,1,-1,1,1,-1,1,1},{-1,1,1,1,-1,1,1,-1,1,-1,1,1},{-1,1,1,1,-1,1,1,1,-1,1,1,1},{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1},{1,-1,1,-1,1,-1,1,-1,1,1,-1,1},{1,-1,1,-1,1,-1,1,1,-1,1,1,-1},{1,-1,1,-1,1,1,-1,1,1,-1,1,-1},{1,-1,1,-1,1,1,-1,1,1,1,-1,1},{1,-1,1,1,-1,1,1,-1,1,-1,1,-1},{1,-1,1,1,-1,1,1,-1,1,1,-1,1},{1,-1,1,1,-1,1,1,1,-1,1,1,-1},{1,1,-1,1,1,-1,1,-1,1,-1,1,-1},{1,1,-1,1,1,-1,1,-1,1,1,-1,1},{1,1,-1,1,1,-1,1,1,-1,1,1,-1},{1,1,-1,1,1,1,-1,1,1,-1,1,-1},{1,1,-1,1,1,1,-1,1,1,1,-1,1}}

c = MatrixForm[Union[Table[{1, b[[i,1]] * b[[i,3]] , b[[i,3]] * b[[i,5]] , b[[i,5]] * b[[i,7]], b[[i,7]] * b[[i,9]], b[[i,9]] * b[[i,11]], b[[i,11]] * b[[i,1]] }, {i, 1 , Length[a]} ] ] ]


import cdd
mat = cdd.Matrix(
[
 [1, -1, -1, -1, -1, -1, -1],
 [1, -1, -1, -1, -1, 1, 1],
 [1, -1, -1, -1, 1, 1, -1],
 [1, -1, -1, 1, -1, -1, 1],
 [1, -1, -1, 1, 1, -1, -1],
 [1, -1, -1, 1, 1, 1, 1],
 [1, -1, 1, -1, -1, 1, -1],
 [1, -1, 1, 1, -1, -1, -1],
 [1, -1, 1, 1, 1, 1, -1],
 [1, 1, -1, -1, -1, -1, 1],
 [1, 1, -1, -1, 1, -1, -1],
 [1, 1, -1, -1, 1, 1, 1],
 [1, 1, 1, -1, -1, -1, -1],
 [1, 1, 1, -1, -1, 1, 1],
 [1, 1, 1, 1, -1, -1, 1],
 [1, 1, 1, 1, 1, -1, -1],
 [1, 1, 1, 1, 1, 1, 1]
]
 )
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

nearity 1  16
begin
 16 7 rational
 1 0 0 0 0 1 0
 1 1 -1 1 -1 1 0
 1 0 0 1 0 0 0
 1 0 1 0 0 0 0
 1 1 0 0 0 0 0
 1 0 0 0 1 0 0
 1 -1 1 -1 1 -1 0
 1 0 0 -1 1 -1 0
 1 0 0 0 0 -1 0
 1 0 -1 1 -1 0 0
 1 0 0 0 -1 0 0
 1 0 0 -1 0 0 0
 1 -1 1 -1 0 0 0
 1 -1 0 0 0 0 0
 1 0 -1 0 0 0 0
 0 -1 1 -1 1 -1 1
end

~~~~~~~~~~~~~~~~~~~~~~~~~

import cdd
mat = cdd.Matrix(
[
 [1,-1, 1, 1, -1, 1, -1, 1, -1, 1, -1, 1, 1],
 [1,-1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1],
 [1,-1, 1, 1, -1, 1, 1, -1, 1, 1, -1, 1, 1],
 [1,-1, 1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1],
 [1,-1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1],
 [1,1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1],
 [1,1, -1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1],
 [1,1, -1, 1, -1, 1, -1, 1, 1, -1, 1, 1, -1],
 [1,1, -1, 1, -1, 1, 1, -1, 1, 1, -1, 1, -1],
 [1,1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1],
 [1,1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 1, -1],
 [1,1, -1, 1, 1, -1, 1, 1, -1, 1, 1, -1, 1],
 [1,1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1],
 [1,1, 1, -1, 1, 1, -1, 1, -1, 1, -1, 1, -1],
 [1,1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1],
 [1,1, 1, -1, 1, 1, -1, 1, 1, -1, 1, 1, -1],
 [1,1, 1, -1, 1, 1, 1, -1, 1, 1, -1, 1, -1],
 [1,1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1]
]
 )
poly = cdd.Polyhedron(mat)
ine = poly.get_inequalities()
print(ine)

H-representation
linearity 6  13 14 15 16 17 18
begin
 18 13 rational
 0 1 1 0 -1 0 1 0 -1 0 1 0 0
 0 1 1 0 0 0 0 0 0 0 0 0 0
 0 1 1 0 -1 0 1 0 0 0 0 0 0
 1 0 0 0 0 0 0 0 0 0 -1 0 0
 1 0 -1 0 1 0 -1 0 1 0 -1 0 0
 1 0 0 0 0 0 -1 0 0 0 0 0 0
 1 0 0 0 -1 0 0 0 0 0 0 0 0
 1 -1 -1 0 1 0 -1 0 1 0 0 0 0
 1 0 0 0 0 0 0 0 -1 0 0 0 0
 1 0 -1 0 0 0 0 0 0 0 0 0 0
 1 -1 -1 0 1 0 0 0 0 0 0 0 0
 1 -1 0 0 0 0 0 0 0 0 0 0 0
 -1 1 1 1 0 0 0 0 0 0 0 0 0
 0 -1 -1 0 1 1 0 0 0 0 0 0 0
 -1 1 1 0 -1 0 1 1 0 0 0 0 0
 0 -1 -1 0 1 0 -1 0 1 1 0 0 0
 -1 1 1 0 -1 0 1 0 -1 0 1 1 0
 0 0 -1 0 1 0 -1 0 1 0 -1 0 1
end


################################################################################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%################################################

BeginPackage["ThreeValuedMeasures`"];

ThreeValuedMeasures[contexts_] := Module[{
  numberofelements, dimension, numberofcontexts, colors,
  allcolorconfigurations, allcoloringswithrepetitions, alllegalcolorings, auxdim, coldim,
  colorreassignment, twovaluedmeasures, twovaluedmeasurescolorconfigurations,
  threevaluedmeasures, threevaluedmeasurescolorconfigurations
},

  (* Count elements, dimensions, and contexts *)
  numberofelements = Length[Union[Flatten[contexts]]];
  dimension = Length[contexts[[1]]];
  numberofcontexts = Length[contexts];

  (* Define colors based on dimension *)
  colors = Table[i, {i, 1, dimension}];

  (* Generate all possible color configurations *)
  allcolorconfigurations = Tuples[colors, numberofelements];

  (* Generate all colorings with repetitions *)
  allcoloringswithrepetitions =
    Table[allcolorconfigurations[[i, contexts[[j, k]]]], {i, 1, Length[allcolorconfigurations]},
          {j, 1, numberofcontexts}, {k, 1, dimension}];

  (* Find legal colorings *)
  alllegalcolorings = {};
  auxdim = Table[dimension, {j, 1, numberofcontexts}];
  Do[
    coldim = Table[Length[Union[allcoloringswithrepetitions[[i, j]]]], {j, 1, numberofcontexts}];
    If[coldim == auxdim, AppendTo[alllegalcolorings, allcoloringswithrepetitions[[i]]]],
    {i, 1, Length[allcoloringswithrepetitions]}
  ];

  (* Find legal color configurations *)
  alllegalcolorconfigurations = {};
  Do[
    coldim = Table[Length[Union[allcoloringswithrepetitions[[i, j]]]], {j, 1, numberofcontexts}];
    If[coldim == auxdim, AppendTo[alllegalcolorconfigurations, allcolorconfigurations[[i]]] ],
    {i, 1, Length[allcoloringswithrepetitions]}
  ];

  (* Define color reassignment for two-valued measures *)
  colorreassignment = {1, 0, 0,0};

  (* Two-valued measures *)
  twovaluedmeasures =
    Union[Table[
      colorreassignment[[alllegalcolorings[[i, j, k]]]],
      {i, 1, Length[alllegalcolorconfigurations]}, {j, 1, numberofcontexts}, {k, 1, dimension}
    ]];

  twovaluedmeasurescolorconfigurations =
    Union[Table[
      colorreassignment[[alllegalcolorconfigurations[[i, k]]]],
      {i, 1, Length[alllegalcolorconfigurations]}, {k, 1, numberofelements}
    ]];

  (* Define color reassignment for three-valued measures *)
  colorreassignment = {1, 2, 3,4};

  (* Three-valued measures *)
  threevaluedmeasures =
    Union[Table[
      colorreassignment[[alllegalcolorings[[i, j, k]]]],
      {i, 1, Length[alllegalcolorconfigurations]}, {j, 1, numberofcontexts}, {k, 1, dimension}
    ]];

  threevaluedmeasurescolorconfigurations =
    Union[Table[
      colorreassignment[[alllegalcolorconfigurations[[i, k]]]],
      {i, 1, Length[alllegalcolorconfigurations]}, {k, 1, numberofelements}
    ]];

  (* Print results *)
  Print["Two-valued measures"];
  Print[twovaluedmeasures];
  Print["Two-valued measures color configurations"];
  Print[twovaluedmeasurescolorconfigurations];

  Print["Three-valued measures"];
  Print[threevaluedmeasures];
  Print["Three-valued measures color configurations"];
  Print[threevaluedmeasurescolorconfigurations];
];

EndPackage[];



################################################################################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%################################################



BeginPackage["TwoValuedStates`"];

TwoValuedStates[contexts_] := Module[{
  numberofelements, dimension, numberofcontexts, colors,
  allcolorconfigurations, allcoloringswithrepetitions, alllegalcolorings, auxdim, coldim
},

  (* Count elements, dimensions, and contexts *)
  numberofelements = Length[Union[Flatten[contexts]]];
  dimension = Length[contexts[[1]]];
  numberofcontexts = Length[contexts];

  (* Define colors and all possible color configurations *)
  colors = {1, 0};
  allcolorconfigurations = Tuples[colors, numberofelements];

  (* Generate all colorings with repetitions *)
  allcoloringswithrepetitions =
    Table[allcolorconfigurations[[i, contexts[[j, k]]]], {i, 1, Length[allcolorconfigurations]},
          {j, 1, numberofcontexts}, {k, 1, dimension}];

  (* Find legal colorings *)
  alllegalcolorings = {};
  auxdim = Table[1, {j, 1, numberofcontexts}];
  Do[
    coldim = Table[Sum[allcoloringswithrepetitions[[i, j, k]], {k, 1, dimension}], {j, 1, numberofcontexts}];
    If[coldim == auxdim, AppendTo[alllegalcolorings, allcoloringswithrepetitions[[i]]]],
    {i, 1, Length[allcoloringswithrepetitions]}
  ];

  (* Print results *)
  Print["number of elements"];
  Print[numberofelements];
  Print["number of dimensions"];
  Print[dimension];
  Print["number of contexts"];
  Print[numberofcontexts];
  Print["number of two-valued states"];
  Print[Length[alllegalcolorings]];
  Print[alllegalcolorings];

  (* Find legal color configurations (optional) *)
  alllegalcolorconfigurations = {};
  Do[
    coldim = Table[Sum[allcoloringswithrepetitions[[i, j, k]], {k, 1, dimension}], {j, 1, numberofcontexts}];
    If[coldim == auxdim, AppendTo[alllegalcolorconfigurations, allcolorconfigurations[[i]]] ],
    {i, 1, Length[allcoloringswithrepetitions]}
  ];
  Print["Travis matrix"];
  Print[alllegalcolorconfigurations];
];

EndPackage[];

################################################################################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%################################################


BeginPackage["DichotomicValuedStates`"];

DichotomicValuedStates[contexts_] := Module[{
  numberofelements, dimension, numberofcontexts, colors,
  allcolorconfigurations, allcoloringswithrepetitions, alllegalcolorings, auxdim, coldim
},

  (* Count elements, dimensions, and contexts *)
  numberofelements = Length[Union[Flatten[contexts]]];
  dimension = Length[contexts[[1]]];
  numberofcontexts = Length[contexts];

  (* Define colors and all possible color configurations *)
  colors = {-1, 1};
  allcolorconfigurations = Tuples[colors, numberofelements];

  (* Generate all colorings with repetitions *)
  allcoloringswithrepetitions =
    Table[allcolorconfigurations[[i, contexts[[j, k]]]], {i, 1, Length[allcolorconfigurations]},
          {j, 1, numberofcontexts}, {k, 1, dimension}];

  (* Find legal colorings *)
  alllegalcolorings = {};
  auxdim = Table[1, {j, 1, numberofcontexts}];
  Do[
    coldim = Table[Sum[allcoloringswithrepetitions[[i, j, k]], {k, 1, dimension}], {j, 1, numberofcontexts}];
    If[coldim == auxdim, AppendTo[alllegalcolorings, allcoloringswithrepetitions[[i]]]],
    {i, 1, Length[allcoloringswithrepetitions]}
  ];

  (* Print results *)
  Print["number of elements"];
  Print[numberofelements];
  Print["number of dimensions"];
  Print[dimension];
  Print["number of contexts"];
  Print[numberofcontexts];
  Print["number of two-valued states"];
  Print[Length[alllegalcolorings]];
  Print[alllegalcolorings];

  (* Find legal color configurations (optional) *)
  alllegalcolorconfigurations = {};
  Do[
    coldim = Table[Sum[allcoloringswithrepetitions[[i, j, k]], {k, 1, dimension}], {j, 1, numberofcontexts}];
    If[coldim == auxdim, AppendTo[alllegalcolorconfigurations, allcolorconfigurations[[i]]] ],
    {i, 1, Length[allcoloringswithrepetitions]}
  ];
  Print["Travis matrix"];
  Print[alllegalcolorconfigurations];
];

EndPackage[];

################################################################################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%################################################


(*

general coloring of (hyper)graphs with an arbitrary number of contexts

no plausibility checks

2024-05-08 Karl Svozil started conceptualization & programming






contexts =
{
{1,2,3},
{1,4,5}
}

*)

contexts =
{
{1,2,3},
{3,4,5},
{5,6,7},
{7,8,9},
{9,10,1}
}

Print ["number of elements"];

numberofelements = Length[ Union[Flatten[ contexts ]]]

Print ["number of dimensions"];

dimension = Length[contexts[[1]]]

Print ["number of contexts"];

numberofcontexts = Length[ contexts ]


colors = Table[i,{i,1,dimension}];

allcolorconfigurations = Tuples[ colors,  numberofelements ];

allcoloringswithrepetitions =   Table[allcolorconfigurations[[ i, contexts[[j, k]] ]], {i, 1,   Length[allcolorconfigurations]}, {j, 1, numberofcontexts}, {k, 1, dimension}];


alllegalcolorings = {};

auxdim = Table[ dimension , {j,1, numberofcontexts}];

Do[coldim =
   Table[Length[Union[allcoloringswithrepetitions[[i, j]]]], {j, 1,  numberofcontexts}];
   If[coldim == auxdim, AppendTo[alllegalcolorings,  allcoloringswithrepetitions[[i]]] ], {i, 1, Length[allcoloringswithrepetitions]}];

Print[alllegalcolorings]

alllegalcolorconfigurations = {};

Do[coldim =
   Table[Length[Union[allcoloringswithrepetitions[[i, j]]]], {j, 1, numberofcontexts}];
   If[coldim == auxdim,  AppendTo[alllegalcolorconfigurations,   allcolorconfigurations[[i]]] ], {i, 1,   Length[allcoloringswithrepetitions]}   ];

Print[alllegalcolorconfigurations]

colorreassignment = {1, 0, 0};

twovaluedmeasures =
 Union[Table[
   colorreassignment[[alllegalcolorings[[i, j, k]]]]
            , {i, 1,  Length[alllegalcolorconfigurations]}, {j, 1,  numberofcontexts}, {k, 1, dimension}]]


twovaluedmeasurescolorconfigurations =
 Union[Table[
   colorreassignment[[alllegalcolorconfigurations[[i, k]]]]
            , {i, 1,  Length[alllegalcolorconfigurations]},  {k, 1, numberofelements}]]

colorreassignment = {-1, 0, 1};

threevaluedmeasures =
 Union[Table[
   colorreassignment[[alllegalcolorings[[i, j, k]]]]
            , {i, 1,  Length[alllegalcolorconfigurations]}, {j, 1,  numberofcontexts}, {k, 1, dimension}]]

threevaluedmeasurescolorconfigurations =
 Union[Table[
   colorreassignment[[alllegalcolorconfigurations[[i, k]]]]
            , {i, 1,  Length[alllegalcolorconfigurations]},  {k, 1, numberofelements}]]

(*********************************************

(*two-valued states on (hyper)graphs with an arbitrary number of \
contexts no plausibility checks 2024-05-08 Karl Svozil started \
conceptualization& programming contexts={{1,2,3},{1,4,5}}*)contexts = \
{{1, 2, 3}, {3, 4, 5}, {5, 6, 7}, {7, 8, 9}, {9, 10, 1}}

Print["number of elements"];

numberofelements = Length[Union[Flatten[contexts]]]

Print["number of dimensions"];

dimension = Length[contexts[[1]]]

Print["number of contexts"];

numberofcontexts = Length[contexts]


colors = {1, 0};

allcolorconfigurations = Tuples[colors, numberofelements];

allcoloringswithrepetitions =
  Table[allcolorconfigurations[[i, contexts[[j, k]]]], {i, 1,   Length[allcolorconfigurations]}, {j, 1, numberofcontexts}, {k, 1, dimension}];


alllegalcolorings = {};

auxdim = Table[1, {j, 1, numberofcontexts}];

Do[
     coldim = Table[Sum[allcoloringswithrepetitions[[i, j, k]], {k, 1, dimension }], {j,   1, numberofcontexts}];
     If[coldim == auxdim, AppendTo[alllegalcolorings, allcoloringswithrepetitions[[i]]]],
   {i,  1, Length[allcoloringswithrepetitions]}
  ];


Print["number of two-valued states"];

Print[Length[alllegalcolorings]]

Print[alllegalcolorings]

alllegalcolorconfigurations = {};

Do[
      coldim = Table[Sum[allcoloringswithrepetitions[[i, j, k]], {k, 1, dimension }], {j,   1, numberofcontexts}];
      If[coldim == auxdim,  AppendTo[alllegalcolorconfigurations,   allcolorconfigurations[[i]]] ],
    {i, 1, Length[allcoloringswithrepetitions]}
   ];


Print["Travis matrix"];

Print[alllegalcolorconfigurations]

*******************************************************************************************)
