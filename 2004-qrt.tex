\documentclass[prl,preprint,showpacs,showkeys,amsfonts,amsmath]{revtex4}
\usepackage{graphicx}

\begin{document}

\title{The diagonalization method in quantum recursion theory}

\author{Karl Svozil}
\email{svozil@tuwien.ac.at}
\homepage{http://tph.tuwien.ac.at/~svozil}
\affiliation{Institut f\"ur Theoretische Physik, University of Technology Vienna,
Wiedner Hauptstra\ss e 8-10/136, A-1040 Vienna, Austria}


\begin{abstract}
Due to the continuity of quantum states,
classical diagonalization has to be revised for quantum recursion theory.
\end{abstract}

\pacs{03.67.-a,03.67.Lx}
\keywords{quantum information theory,quantum recursion theory,diagonalization}

\maketitle

The reasoning in formal logic and recursion theory,
at least insofar as their applicability to worldly things is concerned,
makes implicit assumptions about the physical
meaningfulness (e.g., the actual representability) of the entities of
discourse.
In order for a computational model to be adequate, every capacity of the model
should be reflected in a physical capacity and {\it vice versa}.
It is this postulated isomorphism or correspondence
between theoretical and practical capacities
which confers power to
the formal methods.
We just mention without discussion that the present physical theories,
classical and quantum alike,
can hardly be called computationally adequate:
they are based upon nonconstructive entities such as continua
and {\it a priori} do not exclude transfinite
procedures such as eleatic time squeezing and choices.

In what follows, the diagonalization argument of classical recursive function theory
will be discussed and modified to accommodate  quantum information.
In particular, the possibility of a coherent superposition
of the classical logical truth values makes possible
new consistent solutions to the liar paradox.

Classical information theory is based on the
classical bit as
fundamental atom. This classical bit, henceforth called
{\em cbit,} is in one of two
classical states $t$ interpreted as ``true'' and $f$
interpreted as ``false.''
It is customary to code the classical logical states by
$\ulcorner t\urcorner =1$ and
$\ulcorner f\urcorner =0$ ($
\ulcorner
s
\urcorner$ stands for the code of $s$).
The states can, for instance, be realized by some
condenser who is discharged ($\equiv$ cbit state $0$) or charged
($\equiv$ cbit state $1$).

In quantum information theory \cite{Gruska,nielsen-book},
the elementary unit of information is
 the {\em quantum bit,}
henceforth called {\em qubit}.
Qubits can be physically represented by a coherent
superposition
of the two states $t$ and $f$.
The qubit states
$
x_{\alpha ,\beta}  =\alpha t+\beta f
$
form a continuum, with
$ \vert \alpha \vert^2+\vert \beta \vert^2=1$, $\alpha ,\beta \in {\Bbb
C}$. Qubits can then be coded by
$
\ulcorner
x_{\alpha ,\beta }\urcorner  =(\alpha ,\beta )=
e^{i\varphi } (\sin \omega  ,e^{i\delta } \cos \omega )\quad ,
$
with
$\omega ,\varphi ,\delta \in {\Bbb R}$.
[Alternatively, qubits could be coded by the phases ($\omega ,\varphi ,\delta $).]
In terms of their code, qubits can be identified with cbits as follows
$
(1,0)\equiv 1$
and
$
(0,1)\equiv 0$.


In what follows, it is argued that, due to the superposition principle,
the classical diagonalization method can be reformulated as a fixed point argument.
No {\em reductio ad absurdum} occurs. Instead, undecidability is
recovered as a natural consequence of quantum coherence and of the
unpredictability of certain quantum events.
A quantum diagonalization is presented which, for qubits,
is the analogue of classical diagonalization for cbits.


%\section{Diagonalization}


For the sake of contradiction \cite{rogers1,odi:89},
consider a universal computer $C$ and an arbitrary algorithm
$B(X)$ whose input is a string of symbols $X$.  Assume that there exists
a hypothetical ``halting algorithm'' ${\tt HALT}(B(X))$ which is able to decide whether $B$
terminates on $X$ or not.
The domain of ${\tt HALT}$  is the set of legal programs.
The range of ${\tt HALT}$ are cbits (classical case) and qubits (quantum
mechanical case).

Using ${\tt HALT}(B(X))$,  another deterministic
algorithm  $A$ can be constructed, which accepts as input any effective program $B$ and
which proceeds as follows:  Upon reading the program $B$ as input, $A$
makes a copy of it.  This can be readily achieved, since the program $B$
is presented to $A$ in some encoded form
$\ulcorner B\urcorner $,
i.e., as a string of
symbols.

In the next step, $A$ uses the code
$\ulcorner B\urcorner $
 as input
string for $B$ itself; i.e., $A$ forms  $B(\ulcorner B\urcorner )$,
henceforth denoted by
$B(B)$.
Then, $A$ hands $B(B)$ over to a hypothetical subroutine ${\tt HALT}$
which is assumed to be capable of deciding whether or not $B(B)$ converges; i.e., halts.

Finally, $A$ proceeds as follows:  if ${\tt HALT}(B(B))$ decides that
$B(B)$ converges, then $A$ does not halt.
(This can for instance be realized by an infinite {\tt DO}-loop.)
Alternatively, if ${\tt HALT}(B(B))$ decides
that $B(B)$ diverges, then $A$ halts.

$A$ will now be confronted with the following paradoxical
task to take its own code as input.
%\subsection{Classical case}
 Assume that $A$ is
restricted to classical bits of information.
To be more specific,
assume that ${\tt HALT}$ outputs the code of a cbit as follows
($\uparrow$ and $\downarrow$ stands for divergence and convergence,
respectively):
\begin{equation}
{\tt HALT} ( B(X) ) =\left\{
 \begin{array}{l}
0 \mbox{ if } B(X) \uparrow
\\
1 \mbox{ if } B(X) \downarrow \\
\end{array}
 \right.
\quad .
\label{el:halt}
\end{equation}


Then, whenever $A(A)$
halts, ${\tt HALT}(A(A))$ outputs $1$ and forces $A(A)$ not to halt.
Conversely,
whenever $A(A)$ does not halt, then ${\tt HALT}(A(A))$ outputs $0$
and steers
$A(A)$ into the halting mode.  In both cases one arrives at a complete
contradiction.  Classically, this contradiction can only be consistently
avoided by assuming the nonexistence of $A$ and, since the only
nontrivial feature of $A$ is the use of the peculiar halting algorithm
${\tt HALT}$, the impossibility of any such halting algorithm.


%\subsection{Quantum mechanical case}
In quantum information theory,
a qubit may be in a coherent
superposition
of the two classical states $t$ and $f$.
Due to this possibility of a coherent superposition of classical bit
states, the usual {\it reductio ad absurdum} argument breaks down.
Instead, the classical diagonalization argument yield qubit solutions which are fixed points
of the associated unitary operators.


In what follows it will be demonstrated how the task of $A$
can be performed consistently if
$A$ is allowed to process quantum information.
To be more specific, assume that the output of the hypothetical
``halting algorithm'' is a qubit
\begin{equation}
{\tt HALT} ( B(X) ) = x_{\alpha , \beta}
\quad .
\end{equation}
We may think of   ${\tt HALT} ( B(X) )$ as a universal computer $C'$
simulating $C$ and containing a dedicated {\em halting bit}, which is
the output of $C'$
at every (discrete) time cycle. Initially (at time zero),
this halting bit is prepared to be in a 50:50 mixture of the
classical halting and non-halting states $t$ and $f$; i.e.,
$x_{{1\over \sqrt{2}} , {1\over \sqrt{2}} }$. If $C'$ finds that $C$ converges
(diverges) on $B(X)$, then the halting bit of $C'$ is set to the
classical values $t$ or $f$.


The emergence of fixed points can be demonstrated by a simple example.
Agent $A$'s diagonalization task can be formalized as
follows. Consider for the moment the action of diagonalization  on the
cbit states. (Since the qubit states are merely a coherent superposition
thereof, the action of diagonalization on qubits is straightforward.)
Diagonalization effectively transforms the cbit value $t$ into $f$ and
{\it vice versa.}
Recall that in equation
(\ref{el:halt}),  the state
$t$ has been identified
 with the halting state and the state $f$
with the non-halting
state. Since the halting state and the non-halting state exclude each
other,
$f,t$ can be identified with orthonormal basis vectors  in a
twodimensional vector space. Thus, the standard basis of
Cartesian coordinates can be chosen for a representation of $t$ and $f$;
i.e.,
$
t  \equiv
\left(
1,
0
\right)^T
$ and
$
f \equiv
\left(
0,
1
\right)^T
$, where the superscript ``$T$'' indicates transposition.

The evolution representing diagonalization  can be expressed by the unitary operator $D$ by
$
D t  =  f $ and $
D f  =  t$.
Thus, $D$ acts essentially as a ${\tt not}$-gate.
In the above state basis, $D$ can be represented by
$
D=
\left(
\begin{array}{cc}
0 & 1\\
1 & 0
\end{array}
\right)$.
$ D $ will be called {\em diagonalization} operator, despite the fact
that the only nonvanishing components are off-diagonal.


As has been pointed out earlier,
quantum information theory allows a coherent superposition
$ x_{\alpha ,\beta}  =\alpha t+\beta f $
of the
cbit states $t$ and $f$.
$D$ has a fixed point at the qubit state
\begin{equation}
x^\ast :=x_{ {1\over \sqrt{2}},{1\over \sqrt{2}} }  ={t+f\over \sqrt{2}}
\equiv
{1\over \sqrt{2}} \left(
\begin{array}{c}
1 \\
1
 \end{array}
\right) \quad .
\end{equation}
Suppose a hypothetical quantum halting algorithm ${\tt HALT} ( A(A) ) = x^\ast$
responds with the qubit $x^\ast$, which is the fixed point of $D$.
When applied to the classical diagonalization argument, $x^\ast$
does not give rise to inconsistencies.
For, if a quantum algorithm $A$ processes the fixed point state
$x ^\ast $ through the diagonalization
operator $D$, the same state
$x^\ast $ is recovered.
Stated differently, as long as the output of the ``halting
algorithm'' to input $A(A)$ is $x^\ast$, diagonalization does not
change it. Hence, even if the classical ``paradoxical'' construction
of diagonalization is maintained, quantum theory does not give rise to a
paradox, because the quantum range of solutions is larger than the
classical one.
Therefore,
standard proofs of the recursive unsolvability of the halting problem
do not apply if $A$ is allowed to process qubits. The consequences for
quantum recursion theory are discussed below.






The above argument used the continuity of qubit states as compared to the
two cbit states for a construction of fixed points of the
diagonalization operator. One could proceed a step further and allow
{\em nonclassical diagonalization procedures}. Thereby, one could allow
the entire range of twodimensional unitary transformations
\cite{murnaghan}
\begin{equation}
U_2(\omega ,\alpha ,\beta ,\varphi )=e^{-i\,\beta}\,
\left(
\begin{array}{cc}
{e^{i\,\alpha }}\,\cos \omega
&
{-e^{-i\,\varphi }}\,\sin \omega
\\
{e^{i\,\varphi }}\,\sin \omega
&
{e^{-i\,\alpha }}\,\cos \omega
 \end{array}
\right)
 \quad ,
\label{e:quid3}
\end{equation}
where $-\pi \le \beta ,\omega \le \pi$,
$-\, {\pi \over 2} \le  \alpha ,\varphi \le {\pi \over 2}$, to act on
the qubit.
A typical example of a nonclassical operation on a qubit is
the ``square root of not'' gate
($
\sqrt{{\tt not}}
\sqrt{{\tt not}} =D$)
\begin{equation}
\sqrt{{\tt not}} =
{1 \over 2}
\left(
\begin{array}{cc}
1+i&1-i
\\
1-i&1+i
 \end{array}
\right)
\quad .
\end{equation}
Not all of these unitary transformations have eigenvectors
associated with eigenvalues $1$ and thus fixed points.
Indeed, it is not difficult to see that only
unitary transformations of the form
\begin{equation}
\begin{array}{l}
[U_2(\omega ,\alpha ,\beta ,\varphi )]^{-1}\,\mbox{diag}(1, e^{i\lambda
}) U_2(\omega ,\alpha ,\beta ,\varphi )= \\
\qquad
\qquad
\left(
\begin{array}{cc}
{{\cos^2 \omega }} + {e^{i\,\lambda }}\,{{\sin^2 \omega }}&
{{{
{-1 + {e^{i\,\lambda
}}\over 2}
e^{-i\,\left(\alpha +\varphi \right) }}\,
\, \sin (2\,\omega )}} \\
{ -1 + {e^{i\,\lambda }}\over 2}
 {{{e^{i\,\left(\alpha
+\varphi \right) }}\,
 \sin
(2\,\omega )}}&
{e^{i\,\lambda }}\,{{\cos^2 \omega }} + {{\sin^2 \omega }}
 \end{array}
\right)
 \end{array}
\end{equation}
have fixed points.

Applying nonclassical operations on qubits with no fixed points
\begin{equation}
\begin{array}{l}
[U_2(\omega ,\alpha ,\beta ,\varphi )]^{-1}\,\mbox{diag}( e^{i\mu } ,
e^{i\lambda }) U_2(\omega ,\alpha ,\beta ,\varphi )= \\
\qquad
\qquad
\left(
\begin{array}{cc}
  {e^{i\,\mu }}\,{{\cos^2 \omega }} +
     {e^{i\,\lambda }}\,{{\sin^2 \omega }}&
    {{{e^{-i\,\left( \alpha  + p \right) }\over 2}}\,
         \left( {e^{i\,\lambda }} - {e^{i\,\mu }} \right) \,\sin (2\,\omega )}
       \\
{{{e^{i\,\left( \alpha  + p \right) }\over 2}}\,
        \left( {e^{i\,\lambda }} - {e^{i\,\mu }}  \right) \,\sin (2\,\omega )}
       &{e^{i\,\lambda }}\,{{\cos^2 \omega }} +
     {e^{i\,\mu }}\,{{\sin^2 \omega }}
 \end{array}
\right)
 \end{array}
\end{equation}
with $\mu ,\lambda \neq n\pi$, $n\in {\Bbb N}_0$ gives rise to
eigenvectors which are not fixed points, but which acquire nonvanishing
phases $\mu , \lambda$ in the generalized diagonalization process.


In summary, the classical diagonalization argument has to be formally adopted
for quantum recursion theory.

Note also that the fixed point qubit ``solution''
to the classical halting problem is  not of much practical help.
If one is interested in ``classical,'' dichotomic, yes-no answers,
then one ultimately has to perform an
irreversible measurement
on the fixed point state. This  causes a state reduction into the
classical states corresponding to $t$ and $f$.
Any single measurement will yield an indeterministic result.
There is a 50:50 chance that
the fixed point state will be either in $t$ or $f$, since
$P_t(
x ^\ast)=
P_f(
x^\ast )= {1\over 2}$.
Thereby, classical undecidability is recovered.

Thus, as far as problem solving is concerned, qubits are not much of an
advance. If a classical information is required, then qubits are not
better than probabilistic knowledge. With regards to the question of
whether or not a computer halts, for
instance, the ``solution''
is equivalent to  throwing a fair coin.
Therefore, the advantage of quantum recursion theory over classical
recursion theory is not so much classical problem solving but {\em the
consistent representation of statements} which would give rise to
classical paradoxes.

Another, less abstract, application
inspired by recursion theory is
the handling of inconsistent information in databases.
Thereby,
two contradicting cbits of information
$t$ and
$f $ are resolved by the qubit
$x^\ast =
{(t+f)/ \sqrt{2}}$.
Throughout the rest of the computation the coherence is maintained.
After the processing, the result is obtained by an irreversible
measurement. The processing of qubits, however, might require an
exponential
space overhead on classical computers in cbit base \cite{feynman}.
Thus, in order to remain tractable,
the corresponding qubits should be implemented on
truly quantum universal computers.


%\bibliography{svozil}
%\bibliographystyle{apsrev}

\begin{thebibliography}{6}
\expandafter\ifx\csname natexlab\endcsname\relax\def\natexlab#1{#1}\fi
\expandafter\ifx\csname bibnamefont\endcsname\relax
  \def\bibnamefont#1{#1}\fi
\expandafter\ifx\csname bibfnamefont\endcsname\relax
  \def\bibfnamefont#1{#1}\fi
\expandafter\ifx\csname citenamefont\endcsname\relax
  \def\citenamefont#1{#1}\fi
\expandafter\ifx\csname url\endcsname\relax
  \def\url#1{\texttt{#1}}\fi
\expandafter\ifx\csname urlprefix\endcsname\relax\def\urlprefix{URL }\fi
\providecommand{\bibinfo}[2]{#2}
\providecommand{\eprint}[2][]{\url{#2}}

\bibitem[{\citenamefont{Gruska}(1999)}]{Gruska}
\bibinfo{author}{\bibfnamefont{J.}~\bibnamefont{Gruska}},
  \emph{\bibinfo{title}{Quantum Computing}} (\bibinfo{publisher}{McGraw-Hill},
  \bibinfo{address}{London}, \bibinfo{year}{1999}).

\bibitem[{\citenamefont{Nielsen and Chuang}(2000)}]{nielsen-book}
\bibinfo{author}{\bibfnamefont{M.~A.} \bibnamefont{Nielsen}} \bibnamefont{and}
  \bibinfo{author}{\bibfnamefont{I.~L.} \bibnamefont{Chuang}},
  \emph{\bibinfo{title}{Quantum Computation and Quantum Information}}
  (\bibinfo{publisher}{Cambridge University Press},
  \bibinfo{address}{Cambridge}, \bibinfo{year}{2000}).

\bibitem[{\citenamefont{{Rogers, Jr.}}(1967)}]{rogers1}
\bibinfo{author}{\bibfnamefont{H.}~\bibnamefont{{Rogers, Jr.}}},
  \emph{\bibinfo{title}{Theory of Recursive Functions and Effective
  Computability}} (\bibinfo{publisher}{MacGraw-Hill}, \bibinfo{address}{New
  York}, \bibinfo{year}{1967}).

\bibitem[{\citenamefont{Odifreddi}(1989)}]{odi:89}
\bibinfo{author}{\bibfnamefont{P.}~\bibnamefont{Odifreddi}},
  \emph{\bibinfo{title}{Classical Recursion Theory}}
  (\bibinfo{publisher}{North-Holland}, \bibinfo{address}{Amsterdam},
  \bibinfo{year}{1989}).

\bibitem[{\citenamefont{Murnaghan}(1962)}]{murnaghan}
\bibinfo{author}{\bibfnamefont{F.~D.} \bibnamefont{Murnaghan}},
  \emph{\bibinfo{title}{The Unitary and Rotation Groups}}
  (\bibinfo{publisher}{Spartan Books}, \bibinfo{address}{Washington, D.C.},
  \bibinfo{year}{1962}).

\bibitem[{\citenamefont{Feynman}(1982)}]{feynman}
\bibinfo{author}{\bibfnamefont{R.~P.} \bibnamefont{Feynman}},
  \bibinfo{journal}{International Journal of Theoretical Physics}
  \textbf{\bibinfo{volume}{21}}, \bibinfo{pages}{467} (\bibinfo{year}{1982}).

\end{thebibliography}
\end{document}
